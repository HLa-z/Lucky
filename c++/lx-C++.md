# 入门

## 命名空间

命名空间用于区分不同的库中相同名称的函数、类或变量等。使用了命名空间相当于定义了一个范围。 

**使用：**

```c++
//定义 
namespace 名称 {
	//代码声明
}

//调用带有命名空间的变量或函数
name::code; //code为变量或函数

//指定命名空间，在后续使用时不需加上名称
using namespace name;

//指定命名空间的项目，例如使用std中的cout，后续使用cout不必加上std，但是std中的其他项目时仍需加上std
using std::cout;
```





## 函数重载

函数重载是同一个作用域中的某个函数的多个定义，函数名相同。

参数列表必须不同（个数|类型|顺序）

返回类型不做要求

**作用：**常用来处理实现功能类似数据类型不同的问题，减少了函数名的数量，增加程序的可读性。

**为什么C不支持：**

在编译.c文件时，编译器只会给函数进行简单的重命名，就是在函数名前面加上“_”，当两个函数重名时，在编译之后并无差别。

在.cpp文件中，编译器会在函数名后面加上根据参数列表生成的符号，根据不同的符号来区分函数。



## 引用

**定义：**是某个已存在的对象的别名，对引用的操作相当于对对象的操作。

**语法：**类型 & 引用名 = 变量名；  引用和变量指向相同的内存单元

**注意：**

- 引用的类型要与绑定的对象的类型相同
- 声明引用时必须初始化
- 已有的引用不能再作为其他对象的名字或引用
- 引用不是一个新的变量，所以系统不会为其开辟内存空间

**应用：**

1. 作为参数

   ```c++
   void swap(int & x, int & y){
   	int p = x;
   	y = x;
   	x = p;
   }
   ```

   - 与传递指针效果一样，在被调函数中对形参变量的操作就是对实参的操作
   - 使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效 率和所占空间都好。
   - 使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"***指针变量名**"的 形式进行运算，这很容易产生错误且程序的阅读性较差。

2. 常引用

   如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。

   ```c++
   const 类型 & 引用名 = 变量名;
   ```

3. 引用作为返回值

   - 定义函数时，在函数名前面加上&
   - 用引用返回函数值的好处是在内存中不会产生被返回值得副本。

   规则：

   - 不能返回局部变量的引用。局部变量会在函数返回后被销毁，因此引用就变成了无所指的引用，程序会进入未知状态。

   - 不能返回函数内部new分配的内存的引用。因为被返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间就无法释放。

   - 可以返回类成员的引用，但最好是const。主要原因是当对象的属性是与某种业务规则相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常 量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。

     

## 指针

### 指针和引用的区别

**用指针的使用经常犯得错：**

1. 操作空指针

2. 操作野指针

3. 不知不觉改变了指针的值，而后还以为该指针正常。

   如果我们要正确的使用指针，我们不得不人为地保证这三个条件。而引用的提出就解决了这个问题。

**引用区别于指针的特性是 ：**

1. 不存在空引用（保证不操作空指针）

2. 必须初始化（保证不是野指针）

3. 一个引用永远指向他初始化的那个对象（保证指针值不变）。人为保证变为了编译器来保证，更加安全。

   

## const限定符

const对象一旦创建后，其值就不能再改变。除了不能改变对象的值，其他普通对象能进行的操作，const类型的对象基本都能完成。

默认状态下，const对象仅在文件内有效。要想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。	

### const的引用

把引用绑定到const对象上，为对常量的引用。但是不能通过引用修改它所绑定的对象。

```C++
const int ci = 1024;
const int &r1 = ci; //正确
r1 = 0; //错误
int &r2 = ci; //错误，非常量引用不能绑定常量对象
```





















