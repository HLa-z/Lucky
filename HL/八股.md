## 计网

### 五层协议结构

1. **应用层：**

   * 应用层是体系结构中离用户最近的一层，也是最高层。其任务就是**通过应用进程间的交互来完成特定的网络应用**。

   * 应用层**协议**用来定义**应用进程间通信和交互的规则**。常见的协议有**域名系统DNS**，支持万维网应用的**HTTP**协议；支持电子邮件的**SMTP**协议等。

   * 我们把应用层交互的数据单元称为**报文**。

2. **运输层：**

   * 运输层的任务就是向**两台主机中的应用进程间的通讯**提供**通用的数据传输服务**（向应用层提供传输报文的服务）。

   + **传输控制协议TCP：**
     * 概括：提供**面向连接**的，**可靠的**数据传输服务，数据传输单位为**报文段**。
   + **用户数据报协议UDP：**
     * 概括：提供**无连接**的，**尽最大努力**的数据传输服务（不保证数据传输的可靠性），数据传输单位为**用户数据报**。

3. **网络层：**

   * 网络层为分组交换网上的**不同主机**（不同子网中的主机）之间提供通讯服务。
   * 网络层把运输层的报文段或者用户数据报封装成**分组**或者**包**进行传送。
   * 协议：
     * **地址解析协议ARP：**ip转mac
     * **网际控制报文协议ICMP：**
       * 差错报告报文：
       * 询问报文：如ping
     * **网际组管理协议IGMP**

4. **数据链路层：**

   * 两台主机间传输数据，总是在一段链路上传送的，中间可能要经过路由器（就像一个图），那么相邻结点间的传输就需要用到链路层的协议。

   * 作用：

     * 控制信息：同步信息，地址信息，差错信息等。

     * 向上：把网络层交下来的数据报封装成**帧**，每一帧包含**控制信息**。
     * 向下：通过**控制信息**知道物理层的比特流中从哪到哪是一帧，然后检测这一帧有无差错。

5. **物理层：**

   * 传输**比特流**，规范物理设备的接口



### TCP

* 三次握手：
  * 客户端向服务器发送一个请求报文段，进入SYN-SENT状态；
  * 服务器收到请求报文段后如果同意建立连接，则发送一个应答报文段，进入ACK-RCVD状态；
  * 客户端收到应答报文段后，也发送一个确认报文段给服务器，表明收到应答，连接建立完成。
* 四挥手：
  * TIME_WAIT:![image-20210503142513520](.\八股.assets\image-20210503142513520.png)
* 怎么建立可靠传输：
  * TCP是面向连接的，这是它的一大特点，也是可靠传输的依据之一；
  * 序列号：每个报文都有序列号，要求发送和接受的都是连续的报文段
  * 校验和：TCP将保持首部和数据部分的校验和，检验报文有没有差错
  * 确认应答：每收到一个报文段都要进行应答，发ACK报文
  * 超时重传：对于一个发出去的报文段，迟迟没有收到确认，就会认为丢失，然后重发
  * 流量控制：滑动窗口实现，端到端的问题（局部）
  * 拥塞控制：慢开始，拥塞避免，快重传，快恢复，整个网络的控制



### HTTP

* ![](.\八股.assets\image-20210503153001808.png)
* ![](.\八股.assets\image-20210503153049267.png)
* ![](.\八股.assets\image-20210503153133624.png)
* **报文结构**
  * 请求行：方法，资源路径，协议版本
  * 请求头：key-val的结构
    * user-agent：用户代理，客户端浏览器，操作系统信息
    * Accept：希望接收的数据类型
    * cookie：
    * Host：
  * 请求体：

### SSL/TSL握手

1. 客户端发送Client Hello消息，携带自己支持的加密算法，协议版本，随机字符串等信息
2. 服务器发送Server Hello消息，选择一个加密算法，密码组合，随机字符串等信息，证书
3. 客户端向CA机构查询证书的真实性
4. 用证书中的公钥加密一个premaster key（预主密钥）
5. 客户端根据两个随机字符串+premaster key生成对称加密的密钥，服务器端也是
6. 客户端发送一个密钥加密后的finished信号
7. 服务器端也是
8. 握手完成

### DNS解析

* **过程**
  * ![image-20210706102315890](.\八股.assets\image-20210706102315890.png)





## 操作系统

* **死锁**
  *  死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。
  * **产生死锁四个必要条件**
    * **互斥条件：**一个资源一次只能由一个进程占有，此时有新进程来请求该资源时，只能等待。
    * **请求和保持条件：**一个已经获得资源的进程要申请新的资源，而这个新资源被其他进程占有，那么这个进程就会等待这个新资源被释放，但又对自己以获得的资源保持不放。
    * **不可剥夺条件：**对于以获得的资源，在未使用完之前，不能被剥夺，只能在使用完后自动释放。
    * **环路等待条件：**存在若干个进程，0-n，0在等待1占用的资源，1等2......n等0，形成一个等待链，谁都无法推进。
* **线程和进程**
  * ![](.\八股.assets\image-20210427214415044.png)
* **协程**
  * 类似于一个进程可以拥有多个线程，一个线程也可以拥有多个协程，协程是比线程更轻量级的存在。协程运行在用户态，用程序所控制，性能高，消耗资源少。
* **页面置换算法**
  * 最佳置换算法（opt）
  * 先进先出页面置换算法（FIFO）
  * 最近最久未使用（LRU）：
    * 当发生缺页时，讲最长时间未使用的页面的置换出去。
    * 数据结构：哈希表+双向链表
    * 哈希表用于快速的知道某个页面有没有在内存中，双向链表用于快速的删除和插入
    * 存在链表中的页面，先将它从表中删除，然后放到链尾。
  * 最少使用（LFU）：
* **进程调度算法**
  * 先来先服务
  * 短作业优先
  * 最短剩余时间优先
  * 时间片轮转
  * 优先级调度
* **IO多路复用**
  * [select、poll、epoll之间的区别(搜狗面试) - aspirant - 博客园 (cnblogs.com)](https://www.cnblogs.com/aspirant/p/9166944.html)
* **用户态和内核态**
  * 用户态和内核态的存在是出于安全考虑，处于用户态的进程只能访问受限内存，不可访问外围设备，cpu占用权可被剥夺；处于内核态时cpu可以访问任何数据，和所有外围设备。

* **进程间通信**
  * [(4条消息) 进程间的通信方式——pipe（管道）_sky_Mata的博客-CSDN博客_进程管道](https://blog.csdn.net/skyroben/article/details/71513385)
  * [(4条消息) 进程间通信方式——信号量（Semaphore）_sky_Mata的博客-CSDN博客_信号量进程间通信](https://blog.csdn.net/skyroben/article/details/72513985)





## 数据库

* **事务（acid）**
  * [ACID - 简书 (jianshu.com)](https://www.jianshu.com/p/fc8a654f2205)
  * 四个特性：
    * 原子性：一个事务中的操作，要么全部成功提交，要么失败全部回滚。
    * 一致性：事务的执行不能破坏数据库的一致性（分布式数据库中多个节点保持数据统一）。
    * 隔离性：各事务并发执行时要相互隔离，互不干扰，不同的事务并发操作相同数据时，有各自的执行空间。
    * 持久性：一旦事务提交成功，该事务对数据库中数据的更新是永久保留在数据库中的。
  * ![image-20210702211022377](.\八股.assets\image-20210702211022377.png)
  * ![image-20210702150944487](.\八股.assets\image-20210702150944487.png)
  * ![](.\八股.assets\image-20210427221343940.png)
  * **隔离实现**
    * MVCC多版本并发控制：
      * MVCC可以提供基于某个时间点的快照，使得对于事务看来，总是可以提供与事务开始时刻相一致的数据，而不管这个事务执行的时间有多长。所以在不同的事务看来，同一时刻看到的相同行的数据可能是不一样的，即一个行可能有多个版本。
      * 实现：
        1. 添加两个隐藏列，一个是创建时间tc（事务id），一个是删除时间td（事务id），初始为undefined；
        2. insert：tc = 当前事务id，td = undefined；
        3. delete：更新td = 当前事务id；
        4. update：改为执行insert+delete，原来的行td = tnow，新行执行insert；
        5. select：取出的行满足两个条件：①tc <= tnow && (td > tnow || td == undefined)
      * 优点：不用锁，降低了系统的开销，每个查询只需要比对版本信息即可，提高并发性。
      * 缺点：为了实现多版本，innodb必须对每行增加相应的字段来存储版本信息，同时需要维护每一行的版本信息，而且在检索行的时候，需要进行版本的比较，因而降低了查询的效率；innodb还必须定期清理不再需要的行版本，及时回收空间，这也增加了一些开销。
    * 乐观锁和悲观锁：[(4条消息) 数据库锁分类和总结_weixin_39651041的博客-CSDN博客](https://blog.csdn.net/weixin_39651041/article/details/79985715)





## C++

* **C++多态怎么实现**

  * 满足条件：
    * 有继承关系
    * 子类重写父类虚函数
  * 使用条件
    * 父类指针或者引用指向子类对象

* **hashmap实现原理**

  * 把任意长度的输入，通过哈希算法（有很多种），压缩成固定长度存储。
  * 冲突：一个输入有多个输出值。
  * 数据结构：哈希表，数组里存链表，链表里一个key一个value和一个next指针。

* **c++11新特性**
  
  * auto关键字：根据初始化表达式自动推断出变量的类型，要求变量必须被初始化。
  * nullptr：解决了NULL的二义性问题，NULL可以表示空指针，也可以表示0。
  * for(type i : arrs):基于范围的for循环。
  * 扩展sizeof：再c++98里，对非静态成员变量sizeof是无法通过编译的。
  
* **左值、右值**
  
  * 左值是可以获取地址的变量，右值不能获取，比如一些临时变量（a = ==10 + 30==）.
  
* **虚函数原理，为什么要虚函数**

  * 在一个类的函数定义为虚函数时，会将这个些函数存储到一个虚函数表中，类的实例发生函数调用时，会在实例的虚函数表中寻找这个函数。
  * 子类在继承父类时会继承父类的虚函数表
  * 当子类重写父类虚函数时，会覆盖子类虚函数表中对应虚函数的入口地址。
  * 为什么要虚函数

* **结构体内存问题**

  * 结构体内成员按声明顺序存储（地址不连续），结构体地址与第一个成员变量地址相同；

  * 对结构体sizeof时，要考虑内存对齐，未特殊声明时，向最大内存的变量对其

    * ```c++
      struct Node{
          int x;
          double f;
      }a;
      sizof(a) == 16 即两倍double
      ```

* **类的内存：**

  * 空类的内存大小为1
  * 静态成员变量

* **指针和引用**

  * 指针是一个变量，存储的是一个地址；引用是一个变量的别名，跟原变量是一个东西。
  * 多级：指针可以有多级，就是一个指针指向另一个指针所在的地址；引用只能有一级。
  * 为空：指针可以为空；引用必须被初始化。
  * 改变：指针可以改变所指变量地址，引用一旦初始化不能改变；
  * sizeof：指针得到指针的大小；引用会得到所引用变量的大小。

* **new和malloc区别**

  * new是c++运算符，可以重载，malloc是库函数
  * new是类型安全的，在分配内存时会自动计算所需内存，返回一个类的对象指针；malloc不是类型安全的，根据设置的内存大小申请内存，返回void*指针。
  * new和delete会分别调用构造函数和析构函数，malloc和free不会。
  
* **五大数据区**

  * **常量区：**存储了未被作为初始化使用的字符串常量和const修饰的全局变量，只读不写。
  * **代码区：**存放代码
  * **全局数据区（静态区）**：存储了全部的全局变量，和所有被static修饰的变量（包括局部）。
  * **堆**:是由操作系统负责维护的大片内存池，使用时需手动申请, 一般是调用 malloc 家族函数进行动态内存分配，但使用完毕后需要使用 free 手动释放，否则会造成严重的内存泄漏。所有分配的内存当该进程退出后就会被操作系统回收，但是对于需要长期运行的服务器程序来说，就必须保证内存泄漏尽量少(完全没有基本不可能，除非程序很简单)。
  * **栈**：存储了所有自动存储（不加任何存储类型关键字( static 等)修饰或被 auto 修饰）的局部变量，其特点是生命周期很短，仅仅是该变量所在函数的一次调用过程, 函数被调用时被自动分配并在函数返回后回收。
  
* **指针常量和常量指针**

  * const int* p; //p可变,p指向的内容不可变
    int const* p; //p可变,p指向的内容不可变
    int* const p; //p不可变,p指向的内容可变

    const修饰函数返回值表示返回值不可改变,多用于返回指针的情形
    volatile可理解为编译器警告指示字
    volatile用于告诉编译器必须每次去内存中取变量值
    volatile主要修饰可能被多个线程访问的变量
    volatile也可以修饰可能被未知因数更改的变量





